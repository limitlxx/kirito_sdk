/**
 * Noir Circuit Integration for Mystery Box Reveals
 * Handles compilation and execution of Noir circuits for ZK proofs
 * Uses @noir-lang/noir_js and @aztec/bb.js for proof generation
 */
import { ZKProof, CompiledCircuit, TokenId, BoxId, HiddenData, RevealConditions } from '../types';
export interface NoirMysteryBoxInputs {
    box_id: string;
    token_id: string;
    current_timestamp: number;
    merkle_root: string;
    nullifier: string;
    reveal_type: number;
}
export interface NoirMysteryBoxWitness {
    traits: NoirHiddenTrait[];
    trait_count: number;
    encryption_key: string;
    reveal_conditions: NoirRevealConditions;
    merkle_proof: string[];
    action_proof: string;
    bluff_category: number;
}
export interface NoirHiddenTrait {
    category: number;
    trait_hash: string;
    value_hash: string;
    yield_multiplier: number;
}
export interface NoirRevealConditions {
    condition_type: number;
    timestamp: number;
    required_action: number;
    minimum_stake: number;
    action_completed: boolean;
}
export declare const REVEAL_CONDITIONS: {
    readonly TIMELOCK: 1;
    readonly ACTION: 2;
    readonly COMBINED: 3;
};
export declare const ACTION_TYPES: {
    readonly STAKE_MINIMUM: 1;
    readonly GOVERNANCE_PARTICIPATION: 2;
    readonly YIELD_CLAIM: 3;
};
export declare const TRAIT_CATEGORIES: {
    readonly POWER: 1;
    readonly ABILITY: 2;
    readonly YIELD: 3;
    readonly RARITY: 4;
};
/**
 * Noir Circuit Manager for Mystery Box Reveals
 * Handles circuit compilation, proof generation, and verification using Noir and Barretenberg
 * Based on Noir 1.0.0-beta.15 and Barretenberg backend
 */
export declare class NoirMysteryBoxCircuit {
    private noir?;
    private backend?;
    private circuitArtifacts?;
    private compiledCircuit?;
    private isInitialized;
    private circuitPath;
    constructor(circuitPath?: string);
    /**
     * Initialize Noir circuit artifacts
     */
    private initialize;
    /**
     * Initialize Noir and Barretenberg backend
     */
    private initializeNoirBackend;
    /**
     * Load compiled circuit artifacts
     * Loads from target/mystery_box_reveal.json generated by: nargo compile
     */
    private loadCircuitArtifacts;
    /**
     * Get mock circuit artifacts for testing when real circuit isn't compiled
     */
    private getMockCircuitArtifacts;
    /**
     * Compile the mystery box reveal circuit using Nargo
     * Requires nargo to be installed: https://noir-lang.org/docs/getting_started/installation
     */
    compileCircuit(): Promise<CompiledCircuit>;
    /**
     * Generate proof for mystery box reveal using Noir and Barretenberg
     * Uses real Noir circuit execution and Barretenberg proof generation
     */
    generateRevealProof(boxId: BoxId, tokenId: TokenId, hiddenData: HiddenData, revealConditions: RevealConditions, encryptionKey: string, revealType?: 'full' | 'bluffing', bluffCategory?: number): Promise<ZKProof>;
    /**
     * Extract public inputs from Barretenberg proof
     */
    private extractPublicInputsFromProof;
    /**
     * Synchronous hash function for string inputs
     */
    private hashStringSync;
    /**
     * Verify mystery box reveal proof using Barretenberg
     */
    verifyRevealProof(proof: ZKProof, boxId: BoxId, tokenId: TokenId, revealType?: 'full' | 'bluffing'): Promise<boolean>;
    /**
     * Validate proof inputs match expected values
     */
    private validateProofInputs;
    /**
     * Mock verification fallback when Barretenberg is not available
     */
    private mockVerifyProof;
    /**
     * Generate bluffing proof for trait category
     */
    generateBluffingProof(boxId: BoxId, tokenId: TokenId, hiddenData: HiddenData, traitCategory: number, encryptionKey: string): Promise<ZKProof>;
    /**
     * Extract the bluff category from a proof's public inputs
     */
    extractBluffCategory(proof: ZKProof): Promise<number>;
    /**
     * Convert string to Noir Field type
     */
    private stringToField;
    /**
     * Mock proof generation (replaces actual Noir/Barretenberg execution)
     * For bluffing proofs, ensures trait values are not leaked
     */
    private mockProofGeneration;
    /**
     * Hash a string to bytes for privacy-preserving proofs
     */
    private hashToBytes;
    private getCircuitSource;
    private executeCircuit;
    private extractPublicInputs;
    /**
     * Compare two byte arrays for equality
     */
    private compareBytes;
    private convertHiddenDataToNoirTraits;
    private convertRevealConditions;
    private determineTraitCategory;
    private getActionType;
    private generateMerkleRoot;
    private generateMerkleProof;
    private generateNullifier;
    private generateActionProof;
    private hashString;
    private numberToBytes;
    private bytesToNumber;
}
//# sourceMappingURL=noir-integration.d.ts.map